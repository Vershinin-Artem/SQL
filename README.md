# Решение заданий на SQL
<details>
<summary>Решение заданий из тренажера <a href="https://lab.karpov.courses/learning/152/">Karpov.Courses</a>  </summary>

<details>
  <summary>Базовые запросы SQL</summary>
  
  **Задание №1**

Выведите все записи из таблицы **products**.
Поля в результирующей таблице: **product_id**, **name**, **price**
```sql
SELECT *
FROM products
```
**Задание №2**

Выведите все записи из таблицы products, отсортировав их по наименованиям товаров в алфавитном порядке, т.е. по возрастанию. Для сортировки используйте оператор **ORDER BY**.
Поля в результирующей таблице: **product_id**, **name**, **price**
```sql
SELECT product_id,
       name,
       price
FROM   products
ORDER BY name 
```
**Задание №3**

Отсортируйте таблицу **courier_actions** сначала по колонке **courier_id** по возрастанию id курьера, потом по колонке **action** (снова по возрастанию), а затем по колонке **time**, но уже по убыванию — от самого последнего действия к самому первому. Не забудьте включить в результат колонку **order_id**.

Добавьте в запрос оператор **LIMIT** и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: **courier_id**, **order_id**, **action**, **time**
```sql
SELECT courier_id,
       order_id,
       action,
       time
FROM   courier_actions
ORDER BY courier_id, action, time DESC 
LIMIT 1000
```
**Задание №4**

Используя операторы **SELECT**, **FROM**, **ORDER BY** и **LIMIT**, определите 5 самых дорогих товаров в таблице **products**, которые доставляет наш сервис. Выведите их наименования и цену.

Поля в результирующей таблице: **name**, **price**
```sql
SELECT name,
       price
FROM   products
ORDER BY price DESC 
LIMIT 5
```
**Задание №5**

Повторите запрос из предыдущего задания, но теперь колонки name и **price** переименуйте соответственно в **product_name** и **product_price**.

Поля в результирующей таблице: **product_name**, **product_price**
```sql
SELECT name AS product_name,
       price AS product_price
FROM   products
ORDER BY product_price DESC 
LIMIT 5
```
**Задание №6**

Используя операторы **SELECT**, **FROM**, **ORDER BY** и **LIMIT**, а также функцию **LENGTH**, определите товар с самым длинным названием в таблице **products**. Выведите его наименование, длину наименования в символах, а также цену этого товара. Колонку с длиной наименования в символах назовите **name_length**.

Поля в результирующей таблице: name, name_length, price
```sql
SELECT name,
       price,
       length (name) AS name_length
FROM   products
ORDER BY name_length DESC 
LIMIT 1
```
**Задание №7**

Примените последовательно функции **UPPER** и **SPLIT_PART** к колонке name и преобразуйте наименования товаров в таблице **products** так, чтобы от названий осталось только первое слово, записанное в верхнем регистре. Колонку с новым названием, состоящим из первого слова, назовите **first_word**.

В результат включите исходные наименования товаров, новые наименования из первого слова, а также цену товаров. Результат отсортируйте по возрастанию исходного наименования товара в колонке **name**.

Поля в результирующей таблице: **name**, **first_word**, **price**
```sql
SELECT name,
       price,
       upper (split_part (name, ' ', 1)) as first_word
FROM   products
ORDER BY name
```
**Задание №8**

Измените тип колонки **price** из таблицы **products** на **VARCHAR**. Выведите колонки с наименованием товаров, ценой в исходном формате и ценой в формате **VARCHAR**. Новую колонку с ценой в новом формате назовите **price_char**.

Результат отсортируйте по возрастанию исходного наименования товара в колонке name. Количество выводимых записей не ограничивайте.

Поле в результирующей таблице: **name**, **price**, **price_char**
```sql
SELECT name,
       price,
       cast(price AS varchar) AS price_char
FROM   products
ORDER BY name
```
**Задание №9**

Для первых 200 записей из таблицы **orders** выведите информацию в следующем виде (обратите внимание на пробелы):

Заказ № [id заказа] создан [дата]

Полученную колонку назовите **order_info**.
```sql
SELECT concat ('Заказ №', ' ', order_id, ' ', 'создан', ' ', creation_time::date) AS order_info
FROM   orders 
LIMIT 200
```
**Задание №10**

Выведите id всех курьеров и их годы рождения из таблицы **couriers**.

Год рождения необходимо получить из колонки **birth_date**. Новую колонку с годом назовите **birth_year**. Результат отсортируйте сначала по убыванию года рождения курьера (т.е. от самых младших к самым старшим), затем по возрастанию id курьера.

Поля в результирующей таблице: **courier_id**, **birth_year**
```sql
SELECT courier_id,
       date_part('year', birth_date) AS birth_year
FROM   couriers
ORDER BY birth_year DESC, courier_id
```
**Задание №11**

Как и в предыдущем задании, снова выведите id всех курьеров и их годы рождения, только теперь к извлеченному году примените функцию **COALESCE**. Укажите параметры функции так, чтобы вместо **NULL** значений в результат попадало текстовое значение **unknown**. Названия полей оставьте прежними.

Отсортируйте итоговую таблицу сначала по убыванию года рождения курьера, затем по возрастанию id курьера.

Поля в результирующей таблице: **courier_id**, **birth_year**


```sql
SELECT courier_id,
       COALESCE(CAST(date_part('year', birth_date) as varchar),'unknown') AS birth_year
FROM   couriers
ORDER BY birth_year DESC, courier_id
```
**Задание №12**

Давайте представим, что по какой-то необъяснимой причине мы вдруг решили в одночасье повысить цену всех товаров в таблице products на **5%**.

Выведите id и наименования всех товаров, их старую и новую цену. Колонку со старой ценой назовите **old_price**, а колонку с новой — ***new_price**.

Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**, **old_price**, **new_price**
```sql
SELECT product_id,
       name,
       price AS old_price,
       price + (price/100)* 5 AS new_price
FROM   products
ORDER BY new_price DESC, product_id
```
**Задание №13**

Вновь, как и в прошлом задании, повысьте цену всех товаров на **5%**, только теперь к колонке с новой ценой примените функцию **ROUND**. Выведите id и наименования товаров, их старую цену, а также новую цену с округлением. Новую цену округлите до одного знака после запятой, но тип данных не меняйте.

Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**, **old_price**, **new_price**
```sql
SELECT product_id,
       name,
       price AS old_price,
       round(price + (price/100)*5, 1) AS new_price
FROM   products
ORDER BY new_price DESC, product_id
```
**Задание №14**

Повысьте цену на **5%** только на те товары, цена которых превышает **100** рублей. Цену остальных товаров оставьте без изменений. Также не повышайте цену на икру, которая и так стоит **800** рублей. Выведите id и наименования всех товаров, их старую и новую цену. Цену округлять не нужно.

Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**, **old_price**, **new_price**
```sql
SELECT product_id,
       name,
       price AS old_price,
       CASE
       WHEN price > 100 AND price < 800 THEN price * 1.05
       ELSE price 
       END AS new_price
FROM   products
ORDER BY new_price DESC, product_id
```
**Задание №15**

Вычислите НДС каждого товара в таблице **products** и рассчитайте цену без учёта НДС. Выведите всю информацию о товарах, включая сумму налога и цену без его учёта. Колонки с суммой налога и ценой без НДС назовите соответственно **tax** и **price_before_tax**. Округлите значения в этих колонках до двух знаков после запятой.

Результат отсортируйте сначала по убыванию цены товара без учёта НДС, затем по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**, **price**, **tax**, **price_before_tax**
```sql
SELECT product_id,
       name,
       price,
       round((price/1.2)*0.2, 2) AS tax,
       CASE
       WHEN price > 0 THEN round(price - (price/1.2)*0.2, 2)
       ELSE price END AS price_before_tax
FROM   products
ORDER BY price_before_tax DESC, product_id
```
</details>
 <details>
<summary>Фильтрация данных</summary>

   **Задание №1**

Напишите SQL-запрос к таблице **products** и выведите всю информацию о товарах, цена которых не превышает 100 рублей. Результат отсортируйте по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**, **price**
```sql
SELECT product_id,
       name,
       price
FROM   products
WHERE  price <= 100
ORDER BY product_id
```
**Задание №2**

Отберите пользователей женского пола из таблицы users. Выведите только id этих пользователей. Результат отсортируйте по возрастанию id.

Добавьте в запрос оператор **LIMIT** и выведите только 1000 первых id из отсортированного списка.

Поле в результирующей таблице: **user_id**
```sql
SELECT user_id
FROM   users
WHERE  sex = 'female'
ORDER BY user_id 
LIMIT 1000
```
**Задание №3**

Отберите из таблицы **user_actions** все действия пользователей по созданию заказов, которые были совершены ими после полуночи 6 сентября 2022 года. Выведите колонки с id пользователей, id созданных заказов и временем их создания.

Результат должен быть отсортирован по возрастанию id заказа.

Поля в результирующей таблице: **user_id**, **order_id**, **time**
```sql
SELECT user_id,
       order_id,
       time
FROM   user_actions
WHERE  action = 'create_order'
   AND time >= '2022/09/06 00:00:00'
ORDER BY order_id
```
**Задание №4**

Назначьте скидку 20% на все товары из таблицы **products** и отберите те, цена на которые с учётом скидки превышает 100 рублей. Выведите id товаров, их наименования, прежнюю цену и новую цену с учётом скидки. Колонку со старой ценой назовите **old_price**, с новой — **new_price**.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**, **old_price**, **new_price**


```sql
SELECT product_id,
       name,
       price AS old_price,
       price - ((price * 1.2) - price) AS new_price
FROM   products
WHERE  price - ((price * 1.2) - price) > 100
ORDER BY product_id
```
**Задание №5**

Отберите из таблицы **products** все товары, названия которых либо начинаются со слова «чай», либо состоят из пяти символов. Выведите две колонки: id товаров и их наименования.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**
```sql
SELECT product_id,
       name
FROM   products
WHERE  split_part(name, ' ', 1) = 'чай'
    or length(name) = 5
ORDER BY product_id
```
**Задание №6**

Отберите из таблицы **products** все товары, содержащие в своём названии последовательность символов «чай» (без кавычек). Выведите две колонки: id продукта и его название.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**
```sql
SELECT product_id,
       name
FROM   products
WHERE  name like '%чай%'
ORDER BY product_id
```
**Задание №7**

Выберите из таблицы **products id** и наименования только тех товаров, названия которых начинаются на букву «с» и содержат только одно слово.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**
```sql
SELECT product_id,
       name
FROM   products
WHERE  name LIKE 'с%' AND name NOT LIKE '% %'
ORDER BY product_id
```
**Задание №8**

Составьте SQL-запрос, который выбирает из таблицы products все чаи стоимостью больше 60 рублей и вычисляет для них цену со скидкой 25%.

Скидку в % менеджер попросил указать в отдельном столбце в формате текста, то есть вот так: «25%» (без кавычек). Столбцы со скидкой и новой ценой назовите соответственно **discount** и **new_price**.

Также необходимо любым известным способом избавиться от «чайного гриба»: вряд ли менеджер имел в виду и его, когда ставил нам задачу.

Результат должен быть отсортирован по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**, **price**, **discount**, **new_price**
```sql
SELECT product_id,
       name,
       price,
       '25%' AS discount,
       price - ((price * 1.25) - price) AS new_price
FROM   products
WHERE  price > 60
   AND name NOT LIKE '%гриб%'
   AND name LIKE '%чай%'
ORDER BY product_id
```
**Задание №9**

Из таблицы **user_actions** выведите всю информацию о действиях пользователей с id 170, 200 и 230 за период с 25 августа по 4 сентября 2022 года включительно. Результат отсортируйте по убыванию id заказа — то есть от самых поздних действий к самым первым.

Поля в результирующей таблице: **user_id**, **order_id**, **action**, **time**
```sql
SELECT user_id,
       order_id,
       action,
       time
FROM   user_actions
WHERE  user_id in (170, 200, 230)
   AND time BETWEEN '2022-08-25'
   AND '2022-09-05'
ORDER BY time DESC
```
**Задание №10**

Напишите SQL-запрос к таблице **couriers** и выведите всю информацию о курьерах, у которых не указан их день рождения.

Результат должен быть отсортирован по возрастанию id курьера.

Поля в результирующей таблице: **birth_date**, **courier_id**, **sex**
```sql
SELECT birth_date,
       courier_id,
       sex
FROM   couriers
WHERE  birth_date IS NULL
ORDER BY courier_id
```
**Задание №11**

Определите id и даты рождения 50 самых молодых пользователей мужского пола из таблицы **users**. Не учитывайте тех пользователей, у которых не указана дата рождения.

Поле в результирующей таблице: **user_id**, **birth_date**
```sql
SELECT user_id,
       birth_date
FROM   users
WHERE  birth_date IS NOT NULL
   AND sex = 'male'
ORDER BY birth_date DESC
LIMIT 50
```
**Задание №12**

Напишите SQL-запрос к таблице **courier_actions**, чтобы узнать id и время доставки последних 10 заказов, доставленных курьером с id 100.

Поля в результирующей таблице: **order_id**, **time**
```sql
SELECT order_id,
       time
FROM   courier_actions
WHERE  courier_id = '100'
   AND action = 'deliver_order'
ORDER BY time DESC 
LIMIT 10
```
**Задание №13**

Из таблицы **user_actions** получите id всех заказов, сделанных пользователями сервиса в августе 2022 года.

Результат отсортируйте по возрастанию id заказа.

Поле в результирующей таблице: **order_id**
```sql
SELECT order_id
FROM   user_actions
WHERE  action = 'create_order'
   AND date_part('month', time) = '08'
ORDER BY order_id
```
**Задание №14**

Из таблицы **couriers** отберите id всех курьеров, родившихся в период с 1990 по 1995 год включительно.

Результат отсортируйте по возрастанию id курьера.

Поле в результирующей таблице: **courier_id**
```sql
SELECT courier_id
FROM   couriers
WHERE  date_part('year', birth_date) BETWEEN '1990' AND '1995'
ORDER BY courier_id
```
**Задание №15**

Из таблицы **user_actions** получите информацию о всех отменах заказов, которые пользователи совершали в течение августа 2022 года по средам с 12:00 до 15:59.

Результат отсортируйте по убыванию id отменённых заказов.

Поля в результирующей таблице: **user_id**, **order_id**, **action**, **time**
```sql
SELECT user_id,
       order_id,
       action,
       time
FROM   user_actions
WHERE  action = 'cancel_order'
   AND date_part('month', time) = '08'
   AND date_part('dow', time) = '03'
   AND date_part('hour', time) BETWEEN 12
   AND 15
ORDER BY order_id DESC
```
**Задание №16**

Как и в задаче из прошлого урока, вычислите НДС каждого товара в таблице products и рассчитайте цену без учёта НДС. Однако теперь примите во внимание, что для товаров из списка налог составляет 10%. Для остальных товаров НДС тот же — 20%.

Выведите всю информацию о товарах, включая сумму налога и цену без его учёта. Колонки с суммой налога и ценой без НДС назовите соответственно tax и **price_before_tax**. Округлите значения в этих колонках до двух знаков после запятой.

Результат отсортируйте сначала по убыванию цены товара без учёта НДС, затем по возрастанию id товара.

Поля в результирующей таблице: **product_id**, **name**, **price**, **tax**, **price_before_tax**
```sql
SELECT product_id,
       name,
       price,
       
    CASE 
       WHEN name IN ('сахар', 'сухарики', 'сушки', 'семечки', 'масло льняное', 'виноград', 'масло оливковое', 'арбуз', 'батон', 'йогурт', 'сливки', 'гречка', 'овсянка', 'макароны', 'баранина', 'апельсины', 'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 'мука', 'шпроты', 'сосиски', 'свинина', 'рис', 'масло кунжутное', 'сгущенка', 'ананас', 'говядина', 'соль', 'рыба вяленая', 'масло подсолнечное', 'яблоки', 'груши', 'лепешка', 'молоко', 'курица', 'лаваш', 'вафли', 'мандарины') THEN round(price / 110 * 10, 2)
        ELSE round(price / 120 * 20, 2) 
        END AS tax,
       
    CASE 
        WHEN name IN ('сахар', 'сухарики', 'сушки', 'семечки', 'масло льняное', 'виноград', 'масло оливковое', 'арбуз', 'батон', 'йогурт', 'сливки', 'гречка', 'овсянка', 'макароны', 'баранина', 'апельсины', 'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 'мука', 'шпроты', 'сосиски', 'свинина', 'рис', 'масло кунжутное', 'сгущенка', 'ананас', 'говядина', 'соль', 'рыба вяленая', 'масло подсолнечное', 'яблоки', 'груши', 'лепешка', 'молоко', 'курица', 'лаваш', 'вафли', 'мандарины') THEN round(price - price / 110 * 10, 2)
        ELSE round(price - price / 120 * 20, 2) 
        END AS price_before_tax
FROM   products
ORDER BY price_before_tax DESC, product_id;                                                                                                                                        
```
</details>
<details>
<summary>Агрегация данных SQL</summary>
  
**Задание №1**

Выведите id всех уникальных пользователей из таблицы **user_actions**. Результат отсортируйте по возрастанию id.

Поле в результирующей таблице: **user_id**
```sql
SELECT DISTINCT user_id
FROM user_actions
ORDER BY user_id
```
**Задание №2**

Примените **DISTINCT** сразу к двум колонкам таблицы **courier_actions** и отберите уникальные пары значений **courier_id** и **order_id**.

Результат отсортируйте сначала по возрастанию id курьера, затем по возрастанию id заказа.

Поля в результирующей таблице: **courier_id**, **order_id**
```sql
SELECT DISTINCT courier_id,
                order_id
FROM courier_actions
ORDER BY courier_id, order_id
```
**Задание №3**

Посчитайте максимальную и минимальную цены товаров в таблице **products**. Поля назовите соответственно **max_price**, **min_price**.

Поля в результирующей таблице: **max_price**, **min_price**

```sql
SELECT MAX(price) AS max_price,
       MIN(price) AS min_price
FROM products
```
**Задание №4**

Как вы помните, в таблице users у некоторых пользователей не были указаны их даты рождения.

Посчитайте в одном запросе количество всех записей в таблице и количество только тех записей, для которых в колонке **birth_date** указана дата рождения.

Колонку с общим числом записей назовите **dates**, а колонку с записями без пропусков — **dates_not_null**.

Поля в результирующей таблице: **dates**, **dates_not_null**
```sql
SELECT COUNT(*) AS dates,
       COUNT(birth_date) AS dates_not_null
FROM users
```
**Задание №5**

Посчитайте количество всех значений в колонке **user_id** в таблице **user_actions**, а также количество уникальных значений в этой колонке (т.е. количество уникальных пользователей сервиса).

Колонку с первым полученным значением назовите users, а колонку со вторым — **unique_users**.

Поля в результирующей таблице: **users**, **unique_users**
```sql
SELECT COUNT(DISTINCT user_id) AS unique_users,
       COUNT(user_id) AS users
FROM user_actions
```
**Задание №6**

Посчитайте количество курьеров женского пола в таблице **couriers**. Полученный столбец с одним значением назовите **couriers**.

Поле в результирующей таблице: **couriers**
```sql
SELECT COUNT(courier_id) AS couriers
FROM couriers
WHERE sex = 'female'
```
**Задание №7**

Рассчитайте время, когда были совершены первая и последняя доставки заказов в таблице **courier_actions**.

Колонку с временем первой доставки назовите **first_delivery**, а колонку с временем последней — **last_delivery**.

Поля в результирующей таблице: **first_delivery**, **last_delivery**
```sql
SELECT MIN(time) AS first_delivery,
       MAX(time) AS last_delivery
FROM courier_actions
WHERE  action = 'deliver_order'
```
**Задание №8**

Представьте, что один из пользователей сервиса сделал заказ, в который вошли одна пачка сухариков, одна пачка чипсов и один энергетический напиток. Посчитайте стоимость такого заказа.

Колонку с рассчитанной стоимостью заказа назовите **order_price**.

Для расчётов используйте таблицу **products**.

Поле в результирующей таблице: **order_price**
```sql
SELECT SUM(price) AS order_price
FROM   products
WHERE  name IN('сухарики','чипсы','энергетический напиток')
```
**Задание №9**

Посчитайте количество заказов в таблице **orders** с девятью и более товарами. Для этого воспользуйтесь функцией **array_length**, отфильтруйте данные по количеству товаров в заказе и проведите агрегацию. Полученный столбец назовите orders.

Поле в результирующей таблице: **orders**
```sql
SELECT COUNT(ARRAY_LENGTH(product_ids, 1)) AS orders
FROM orders
WHERE ARRAY_LENGTH(product_ids, 1) >= 9
```
**Задание №10**

С помощью функции **AGE** и агрегирующей функции рассчитайте возраст самого молодого курьера мужского пола в таблице **couriers**.

Возраст выразите количеством лет, месяцев и дней (как в примере выше), переведя его в тип **VARCHAR**. 

В качестве даты, относительно которой считать возраст курьеров, используйте свою текущую дату (либо не указывайте её на месте первого аргумента, как показано в примерах).

Полученную колонку со значением возраста назовите **min_age**.

Поле в результирующей таблице: **min_age**
```sql
SELECT AGE(CURRENT_DATE, MAX(birth_date)) :: varchar as min_age
FROM couriers
WHERE sex = 'male'
```
**Задание №11**

Посчитайте стоимость заказа, в котором будут три пачки сухариков, две пачки чипсов и один энергетический напиток. Колонку с рассчитанной стоимостью заказа назовите **order_price**.

Для расчётов используйте таблицу **products**.

Поле в результирующей таблице: **order_price**
```sql
SELECT SUM(CASE WHEN name = 'сухарики' THEN price * 3
                WHEN name = 'чипсы' THEN price * 2
                WHEN name = 'энергетический напиток' THEN price * 1 
                END) AS order_price
FROM products
```
**Задание №12**

Рассчитайте среднюю цену товаров в таблице **products**, в названиях которых присутствуют слова «чай» или «кофе». Любым известным способом исключите из расчёта товары, содержащие в названии «иван-чай» или «чайный гриб».

Среднюю цену округлите до двух знаков после запятой. Столбец с полученным значением назовите **avg_price**.

Поле в результирующей таблице: **avg_price**
```sql
SELECT round(avg(price), 2) AS avg_price
FROM   products
WHERE  (name LIKE '%чай%'
    OR name LIKE '%кофе%')
   AND name NOT LIKE '%иван-чай%'
   AND name NOT LIKE '%гриб%'
```
**Задание №13**

Воспользуйтесь функцией **AGE** и рассчитайте разницу в возрасте между самым старым и самым молодым пользователями мужского пола в таблице **users**. 

Разницу в возрасте выразите количеством лет, месяцев и дней, переведя её в тип **VARCHAR**. 

Колонку с посчитанным значением назовите **age_diff**.

Поле в результирующей таблице: **age_diff**


```sql
SELECT AGE(MAX(birth_date), MIN(birth_date)) :: varchar as age_diff
FROM users
```
**Задание №14**

Рассчитайте среднее количество товаров в заказах из таблицы orders, которые пользователи оформляли по выходным дням (суббота и воскресенье) в течение всего времени работы сервиса.

Полученное значение округлите до двух знаков после запятой. Колонку с ним назовите **avg_order_size**.

Поле в результирующей таблице: **avg_order_size**
```sql
SELECT ROUND(AVG(ARRAY_LENGTH(product_ids, 1)), 2) AS avg_order_size
FROM orders
WHERE DATE_PART('DOW', creation_time) IN(6, 0)
```
**Задание №15**

На основе данных в таблице **user_actions** посчитайте количество уникальных пользователей сервиса, количество уникальных заказов, поделите одно на другое и выясните, сколько заказов приходится на одного пользователя.

В результирующей таблице отразите все три значения — поля назовите соответственно **unique_users**, **unique_orders**, **orders_per_user**.

Показатель числа заказов на пользователя округлите до двух знаков после запятой.

Поля в результирующей таблице: **unique_users**, **unique_orders**, **orders_per_user**
```sql
SELECT COUNT(DISTINCT(user_id)) AS unique_users,
       COUNT(DISTINCT(order_id)) AS unique_orders,
       ROUND(COUNT(DISTINCT order_id)::decimal/COUNT(DISTINCT user_id),2) AS orders_per_user
FROM user_actions
```
**Задание №16**

Посчитайте, сколько пользователей никогда не отменяли свой заказ. Для этого из общего числа всех уникальных пользователей отнимите число уникальных пользователей, которые хотя бы раз отменяли заказ. Подумайте, какое условие необходимо указать в **FILTER**, чтобы получить корректный результат.

Полученный столбец назовите **users_count**.

Поле в результирующей таблице: **users_count**
```sql
SELECT (COUNT(DISTINCT user_id) - COUNT(DISTINCT user_id) filter (WHERE action = 'cancel_order')) as users_count
FROM user_actions
```
**Задание №17**

Посчитайте общее количество заказов в таблице **orders**, количество заказов с пятью и более товарами и найдите долю заказов с пятью и более товарами в общем количестве заказов.

В результирующей таблице отразите все три значения — поля назовите соответственно **orders**, **large_orders**, **large_orders_share**.

Долю заказов с пятью и более товарами в общем количестве товаров округлите до двух знаков после запятой.

Поля в результирующей таблице: **orders**, **large_orders**, **large_orders_share**
```sql
SELECT COUNT(order_id) AS orders,
       COUNT(product_ids) filter (WHERE (ARRAY_LENGTH(product_ids, 1) >= 5)) AS large_orders,
       ROUND(COUNT(order_id) filter (WHERE ARRAY_LENGTH(product_ids, 1) >= 5)/COUNT(order_id)::decimal,2) as large_orders_share
FROM orders
```
</details>
<details>
<summary>Группировка данных SQL</summary>

  **Задание №1**

С помощью оператора **GROUP BY** посчитайте количество курьеров мужского и женского пола в таблице **couriers**.

Новую колонку с числом курьеров назовите **couriers_count**.

Результат отсортируйте по этой колонке по возрастанию.

Поля в результирующей таблице: **sex**, **couriers_count**
```sql
SELECT sex,
       COUNT(sex) AS couriers_count
FROM couriers
GROUP BY sex
ORDER BY couriers_count
```

**Задание №2**

Посчитайте количество созданных и отменённых заказов в таблице **user_actions**.

Новую колонку с числом заказов назовите **orders_count**.

Результат отсортируйте по числу заказов по возрастанию.

Поля в результирующей таблице: **action**, **orders_count**
```sql
SELECT action,
       COUNT(action) AS orders_count
FROM user_actions
GROUP BY action
ORDER BY orders_count
```

**Задание №3**

Используя группировку и функцию **DATE_TRUNC**, приведите все даты к началу месяца и посчитайте, сколько заказов было сделано в каждом из них.

Расчёты проведите по таблице **orders**. Колонку с усечённой датой назовите **month**, колонку с количеством заказов — **orders_count**.

Результат отсортируйте по месяцам — по возрастанию.

Поля в результирующей таблице: **month**, **orders_count**
```sql
SELECT DATE_TRUNC('month', creation_time) AS month,
       COUNT(order_id) as orders_count
FROM orders
GROUP BY month
ORDER BY month
```

**Задание №4**

Используя группировку и функцию **DATE_TRUNC**, приведите все даты к началу месяца и посчитайте, сколько заказов было сделано и сколько было отменено в каждом из них.

В этот раз расчёты проведите по таблице **user_actions**. Колонку с усечённой датой назовите **month**, колонку с количеством заказов — **orders_count**.

Результат отсортируйте сначала по месяцам — по возрастанию, затем по типу действия — тоже по возрастанию.

Поля в результирующей таблице: **month**, **action**, **orders_count**
```sql
SELECT DATE_TRUNC('month', time) AS month,
       action,
       COUNT(order_id) AS orders_count
FROM user_actions
GROUP BY month, action
ORDER BY month, action
```

**Задание №5**

По данным в таблице **users** посчитайте максимальный порядковый номер месяца среди всех порядковых номеров месяцев рождения пользователей сервиса. С помощью группировки проведите расчёты отдельно в двух группах — для пользователей мужского и женского пола.

Новую колонку с максимальным порядковым номером месяца рождения в группах назовите **max_month**. Преобразуйте значения в новой колонке в формат **INTEGER**, чтобы порядковый номер был выражен целым числом.

Результат отсортируйте по колонке с полом пользователей.

Поля в результирующей таблице: **sex**, **max_month**
```sql
SELECT sex,
       MAX(DATE_PART('month', birth_date)::integer) AS max_month
FROM users
GROUP BY sex
ORDER BY sex
```

**Задание №6**

По данным в таблице **users** посчитайте порядковый номер месяца рождения самого молодого пользователя сервиса. С помощью группировки проведите расчёты отдельно в двух группах — для пользователей мужского и женского пола.

Новую колонку c порядковым номером месяца рождения самого молодого пользователя в группах назовите max_month. Преобразуйте значения в новой колонке в формат **INTEGER**, чтобы порядковый номер был выражен целым числом.

Результат отсортируйте по колонке с полом пользователей.

Поля в результирующей таблице: **sex**, **max_month**
```sql
SELECT sex,
       date_part('month', max(birth_date)):: integer AS max_month
FROM   users
GROUP BY sex
ORDER BY sex
```

**Задание №7**

Посчитайте максимальный возраст пользователей мужского и женского пола в таблице **users**. Возраст измерьте числом полных лет.

Новую колонку с возрастом назовите **max_age**. Преобразуйте значения в новой колонке в формат **INTEGER**, чтобы возраст был выражен целым числом.

Результат отсортируйте по новой колонке по возрастанию возраста.

Поля в результирующей таблице: **sex**, **max_age**
```sql
SELECT sex,
       MAX(DATE_PART('year', AGE(CURRENT_DATE, birth_date))) :: integer as max_age
FROM users
GROUP BY sex
ORDER BY max_age
```

**Задание №8**

Разбейте пользователей из таблицы **users** на группы по возрасту (возраст по-прежнему измеряем числом полных лет) и посчитайте количество пользователей каждого возраста.

Колонку с возрастом назовите **age**, а колонку с числом пользователей — **users_count**. Преобразуйте значения в колонке с возрастом в формат **INTEGER**, чтобы возраст был выражен целым числом.

Результат отсортируйте по колонке с возрастом по возрастанию.

Поля в результирующей таблице: **age**, **users_count**
```sql
SELECT DATE_PART('year', AGE(CURRENT_DATE, birth_date))::integer AS age,
       COUNT(user_id) AS users_count
FROM users
GROUP BY age
ORDER BY age
```

**Задание №9**

Вновь разбейте пользователей из таблицы users на группы по возрасту (возраст по-прежнему измеряем количеством полных лет), только теперь добавьте в группировку ещё и пол пользователя. Затем посчитайте количество пользователей в каждой половозрастной группе.

Все **NULL** значения в колонке **birth_date** заранее отфильтруйте с помощью **WHERE**.

Колонку с возрастом назовите **age**, а колонку с числом пользователей — users_count, имя колонки с полом оставьте без изменений. Преобразуйте значения в колонке с возрастом в формат **INTEGER**, чтобы возраст был выражен целым числом.

Отсортируйте полученную таблицу сначала по колонке с возрастом по возрастанию, затем по колонке с полом — тоже по возрастанию.

Поля в результирующей таблице: **age**, **sex**, **users_count**
```sql
SELECT DATE_PART('year', AGE(CURRENT_DATE, birth_date)) :: integer AS age,
       sex,
       COUNT(user_id) AS users_count
FROM users
WHERE  DATE_PART('year', AGE(CURRENT_DATE, birth_date)) != 0
GROUP BY age, sex
ORDER BY age, sex
```

**Задание №10**

Посчитайте количество товаров в каждом заказе, примените к этим значениям группировку и рассчитайте количество заказов в каждой группе за неделю с 29 августа по 4 сентября 2022 года включительно. Для расчётов используйте данные из таблицы **orders**.

Выведите две колонки: размер заказа и число заказов такого размера за указанный период. Колонки назовите соответственно **order_size** и **orders_count**.

Результат отсортируйте по возрастанию размера заказа.

Поля в результирующей таблице: **order_size**, **orders_count**
```sql
SELECT ARRAY_LENGTH(product_ids, 1) AS order_size,
       COUNT(ARRAY_LENGTH(product_ids, 1)) AS orders_count
FROM orders
WHERE creation_time >= '2022-08-29'
   AND creation_time <= '2022-09-05'
GROUP BY order_size
ORDER BY order_size
```

**Задание №11**

Посчитайте количество товаров в каждом заказе, примените к этим значениям группировку и рассчитайте количество заказов в каждой группе. Учитывайте только заказы, оформленные по будням. В результат включите только те размеры заказов, общее число которых превышает 2000. Для расчётов используйте данные из таблицы **orders**.

Выведите две колонки: размер заказа и число заказов такого размера. Колонки назовите соответственно **order_size** и **orders_count**.

Результат отсортируйте по возрастанию размера заказа.

Поля в результирующей таблице: **order_size**, **orders_count**

Когда решите эту задачу, вернитесь к одной из предыдущих и подумайте, могли бы мы ещё каким-то способом сделать так, чтобы в результат не попала группа с **NULL** значениями. Можете самостоятельно написать ещё один запрос и попробовать сдать его в качестве альтернативного решения.
```sql
SELECT ARRAY_LENGTH(product_ids, 1) AS order_size,
       COUNT(order_id) AS orders_count
FROM orders
WHERE  TO_CHAR(CREATION_TIME, 'D') IN ('2','3','4','5','6')
GROUP BY order_size 
HAVING COUNT(order_id) > '2000'
ORDER BY order_size
```

**Задание №12**

По данным из таблицы **user_actions** определите пять пользователей, сделавших в августе 2022 года наибольшее количество заказов.

Выведите две колонки — id пользователей и число оформленных ими заказов. Колонку с числом оформленных заказов назовите **created_orders**.

Результат отсортируйте сначала по убыванию числа заказов, сделанных пятью пользователями, затем по возрастанию id этих пользователей.

Поля в результирующей таблице: **user_id**, **created_orders**
```sql
SELECT COUNT(user_id) AS created_orders,
       user_id
FROM   user_actions
WHERE  DATE_PART('month', time) = '08'
   AND DATE_PART('year', time) = '2022'
   AND action = 'create_order'
GROUP BY user_id
ORDER BY created_orders DESC, user_id 
LIMIT 5
```

**Задание №13**

А теперь по данным таблицы **courier_actions** определите курьеров, которые в сентябре 2022 года доставили только по одному заказу.

В этот раз выведите всего одну колонку с id курьеров. Колонку с числом заказов в результат включать не нужно.

Результат отсортируйте по возрастанию id курьера.

Поле в результирующей таблице: **courier_id**
```sql
SELECT courier_id
FROM courier_actions
WHERE DATE_PART('month', time) = '09'
   AND action = 'deliver_order'
GROUP BY courier_id 
HAVING COUNT(courier_id) = 1
ORDER BY courier_id
```

**Задание №14**

Из таблицы **user_actions** отберите пользователей, у которых последний заказ был создан до 8 сентября 2022 года.

Выведите только их id, дату создания заказа выводить не нужно.

Результат отсортируйте по возрастанию id пользователя.

Поле в результирующей таблице: **user_id**
```sql
SELECT user_id
FROM   user_actions
WHERE  action = 'create_order'
GROUP BY user_id 
HAVING MAX(time) < '2022-09-08'
ORDER BY user_id
```

**Задание №15**

Разбейте заказы из таблицы **orders** на 3 группы в зависимости от количества товаров, попавших в заказ:

Малый (от 1 до 3 товаров);
Средний (от 4 до 6 товаров);
Большой (7 и более товаров).
Посчитайте число заказов, попавших в каждую группу. Группы назовите соответственно «Малый», «Средний», «Большой» (без кавычек).

Выведите наименования групп и число товаров в них. Колонку с наименованием групп назовите **order_size**, а колонку с числом заказов — **orders_count**.

Отсортируйте полученную таблицу по колонке с числом заказов по возрастанию.

Поля в результирующей таблице: **order_size**, **orders_count**
```sql
SELECT COUNT(order_id) AS orders_count,
       CASE 
       WHEN ARRAY_LENGTH(product_ids, 1) >= 1 AND
                 ARRAY_LENGTH(product_ids, 1) <= 3 THEN 'Малый'
            WHEN ARRAY_LENGTH(product_ids, 1) >= 4 AND
                 ARRAY_LENGTH(product_ids, 1) <= 6 THEN 'Средний'
            WHEN ARRAY_LENGTH(product_ids, 1) >= 7 THEN 'Большой' 
       END AS order_size
FROM orders
GROUP BY order_size
ORDER BY orders_count
```

**Задание №16**

Разбейте пользователей из таблицы **users** на 4 возрастные группы:

от 18 до 24 лет;
от 25 до 29 лет;
от 30 до 35 лет;
старше 36.
Посчитайте число пользователей, попавших в каждую возрастную группу. Группы назовите соответственно «18-24», «25-29», «30-35», «36+» (без кавычек).

В расчётах не учитывайте пользователей, у которых не указана дата рождения. Как и в прошлых задачах, в качестве возраста учитывайте число полных лет.

Выведите наименования групп и число пользователей в них. Колонку с наименованием групп назовите **group_age**, а колонку с числом пользователей — **users_count**.

Отсортируйте полученную таблицу по колонке с наименованием групп по возрастанию.

Поля в результирующей таблице: **group_age**, **users_count**
```sql
SELECT COUNT(user_id) AS users_count,
       CASE 
    WHEN DATE_PART('year', AGE(CURRENT_DATE, birth_date)) >= 18 AND
                 DATE_PART('year', AGE(CURRENT_DATE, birth_date)) <= 24 THEN '18-24'
            WHEN DATE_PART('year', AGE(CURRENT_DATE, birth_date)) >= 25 AND
                 DATE_PART('year', AGE(CURRENT_DATE, birth_date)) <= 29 THEN '25-29'
            WHEN DATE_PART('year', AGE(CURRENT_DATE, birth_date)) >= 30 AND
                 DATE_PART('year', AGE(CURRENT_DATE, birth_date)) <= 35 THEN '30-35'
            WHEN DATE_PART('year', AGE(CURRENT_DATE, birth_date)) >= 36 THEN '36+' 
            END AS group_age
FROM users
WHERE  DATE_PART('year', AGE(CURRENT_DATE, birth_date)) > 0
GROUP BY group_age
ORDER BY group_age
```

**Задание №17**

По данным из таблицы orders рассчитайте средний размер заказа по выходным и будням.

Группу с выходными днями (суббота и воскресенье) назовите **«weekend»**, а группу с будними днями (с понедельника по пятницу) — **«weekdays»** (без кавычек).

В результат включите две колонки: колонку с группами назовите **week_part**, а колонку со средним размером заказа — **avg_order_size**. 

Средний размер заказа округлите до двух знаков после запятой.

Результат отсортируйте по колонке со средним размером заказа — по возрастанию.

Поля в результирующей таблице: **week_part**, **avg_order_size**


```sql
SELECT ROUND(AVG(ARRAY_LENGTH(product_ids, 1)), 2) AS avg_order_size,
       CASE
       WHEN date_part('DOW', CREATION_TIME) IN(0, 6) THEN 'weekend'
       ELSE 'weekdays' 
       END AS week_part
FROM orders
GROUP BY week_part
ORDER BY avg_order_size
```

**Задание №18**

Для каждого пользователя в таблице **user_actions** посчитайте общее количество оформленных заказов и долю отменённых заказов.

Новые колонки назовите соответственно **orders_count** и **cancel_rate**. Колонку с долей отменённых заказов округлите до двух знаков после запятой.

В результат включите только тех пользователей, которые оформили больше трёх заказов и у которых показатель **cancel_rate** составляет не менее 0.5.

Результат отсортируйте по возрастанию id пользователя.

Поля в результирующей таблице: **user_id**, **orders_count**, **cancel_rate**
```sql
SELECT user_id,
       COUNT(DISTINCT order_id) AS orders_count,
       round(COUNT(DISTINCT order_id) FILTER(WHERE action = 'cancel_order')::decimal /COUNT(DISTINCT order_id),2) AS cancel_rate
FROM user_actions
GROUP BY user_id 
HAVING COUNT(DISTINCT order_id) > '3' 
AND ROUND(COUNT(DISTINCT order_id) FILTER(WHERE  action = 'cancel_order')::decimal /COUNT(DISTINCT order_id), 2) >= 0.5
ORDER BY user_id
```

**Задание №19**

Для каждого дня недели в таблице **user_actions** посчитайте:

Общее количество оформленных заказов.
Общее количество отменённых заказов.
Общее количество неотменённых заказов (т.е. доставленных).
Долю неотменённых заказов в общем числе заказов (**success rate**).
Новые колонки назовите соответственно **created_orders**, **canceled_orders**, **actual_orders** и **success_rate**. Колонку с долей неотменённых заказов округлите до трёх знаков после запятой.

Все расчёты проводите за период с 24 августа по 6 сентября 2022 года включительно, чтобы во временной интервал попало равное количество разных дней недели.

Группы сформируйте следующим образом: выделите день недели из даты с помощью функции **to_char** с параметром **'Dy'**, также выделите порядковый номер дня недели с помощью функции **DATE_PART** с параметром **'isodow'**. Далее сгруппируйте данные по двум полям и проведите все необходимые расчёты.

В результате должна получиться группировка по двум колонкам: с порядковым номером дней недели и их сокращёнными наименованиями.

Результат отсортируйте по возрастанию порядкового номера дня недели.

Поля в результирующей таблице: **weekday_number**, **weekday**, **created_orders**, **canceled_orders**, **actual_orders**, **success_rate**
```sql
SELECT TO_CHAR(time, 'Dy') AS weekday,
       DATE_PART('isodow', time) :: int AS weekday_number,
       COUNT(order_id) - COUNT(order_id) filter(WHERE action = 'cancel_order') AS created_orders,
       COUNT(order_id) FILTER(WHERE action = 'cancel_order') AS canceled_orders,
       COUNT(order_id) FILTER(WHERE action = 'create_order') - COUNT(order_id) FILTER(WHERE action = 'cancel_order') AS actual_orders,
       ROUND((COUNT(order_id) FILTER(WHERE action = 'create_order') - COUNT(order_id) FILTER(WHERE action = 'cancel_order'))/(COUNT(order_id) - COUNT(order_id) FILTER(WHERE action = 'cancel_order'))::decimal,3) AS success_rate
FROM   user_actions
WHERE  time >= '2022-08-09'
   AND time <= '2022-09-07'
GROUP BY weekday, weekday_number
ORDER BY weekday_number
```
</details>
<details>
<summary>Подзапросы</summary>
  
# Подзапросы 

**Задание №1**

Используя данные из таблицы **user_actions**, рассчитайте среднее число заказов всех пользователей нашего сервиса.

Для этого сначала в подзапросе посчитайте, сколько заказов сделал каждый пользователь, а затем обратитесь к результату подзапроса в блоке **FROM** и уже в основном запросе усредните количество заказов по всем пользователям.

Полученное среднее число заказов всех пользователей округлите до двух знаков после запятой. Колонку с этим значением назовите **orders_avg**.

Поле в результирующей таблице: **orders_avg**


```sql
SELECT ROUND(AVG(orders_count), 2) AS orders_avg
FROM   (SELECT user_id,
               COUNT (order_id) filter (WHERE action = 'create_order') AS orders_count
        FROM user_actions
        GROUP BY user_id) AS user_orders_count
```

**Задание №2**

Повторите запрос из предыдущего задания, но теперь вместо подзапроса используйте оператор **WITH** и табличное выражение.

Условия задачи те же: используя данные из таблицы **user_actions**, рассчитайте среднее число заказов всех пользователей.

Полученное среднее число заказов округлите до двух знаков после запятой. Колонку с этим значением назовите **orders_avg**.

Поле в результирующей таблице: **orders_avg**

```sql
WITH 
subquery_1 AS (SELECT COUNT(order_id) FILTER(WHERE action = 'create_order') AS orders_count
                    FROM   user_actions
                    GROUP BY user_id)
SELECT ROUND(AVG(orders_count), 2) AS orders_avg
FROM subquery_1
```

**Задание №3**

Выведите из таблицы **products** информацию о всех товарах кроме самого дешёвого.

Результат отсортируйте по убыванию **id** товара.

Поля в результирующей таблице: **product_id**, **name**, **price**
```sql
SELECT product_id,
       name,
       price
FROM products
WHERE price != (SELECT MIN(price)
                FROM   products)
ORDER BY product_id DESC
```

**Задание №4**

Выведите информацию о товарах в таблице **products**, цена на которые превышает среднюю цену всех товаров на 20 рублей и более. Результат отсортируйте по убыванию **id** товара.

Поля в результирующей таблице: **product_id**, **name**, **price**
```sql
WITH 
subquery_1 AS (SELECT AVG(price) AS avg_price
               FROM products)
SELECT product_id,
       name,
       price
FROM   products
WHERE  (SELECT price - avg_price >= 20
        FROM   subquery_1)
ORDER BY product_id DESC
```

**Задание №5**

Посчитайте количество уникальных клиентов в таблице **user_actions**, сделавших за последнюю неделю хотя бы один заказ.

Полученную колонку с числом клиентов назовите **users_count**. В качестве текущей даты, от которой откладывать неделю, используйте последнюю дату в той же таблице **user_actions**.

Поле в результирующей таблице: **users_count**

```sql
WITH 
subquery_1 AS (SELECT MAX(time) AS max_date
                    FROM   user_actions)
SELECT count(DISTINCT user_id) AS users_count
FROM user_actions
WHERE time >= (SELECT max_date
               FROM   subquery_1) - interval '1 week'
```

**Задание №6**

С помощью функции **AGE** и агрегирующей функции снова определите возраст самого молодого курьера мужского пола в таблице **couriers**, но в этот раз при расчётах в качестве первой даты используйте последнюю дату из таблицы **courier_actions**.

Чтобы получить именно дату, перед применением функции **AGE** переведите последнюю дату из таблицы **courier_actions** в формат **DATE**, как мы делали в этом задании.

Возраст курьера измерьте количеством лет, месяцев и дней и переведите его в тип **VARCHAR**. Полученную колонку со значением возраста назовите **min_age**.

Поле в результирующей таблице: **min_age**
```sql
WITH
subquery_1 AS (SELECT MAX(time)::DATE AS max_date
               FROM   courier_actions)
SELECT AGE((SELECT max_date
            FROM subquery_1), MAX(birth_date))::VARCHAR AS min_age
FROM couriers
WHERE sex = 'male'
```

**Задание №7**

Из таблицы **user_actions** с помощью подзапроса или табличного выражения отберите все заказы, которые не были отменены пользователями.

Выведите колонку с **id** этих заказов. Результат запроса отсортируйте по возрастанию **id** заказа.

Добавьте в запрос оператор **LIMIT** и выведите только первые 1000 строк результирующей таблицы.

Поле в результирующей таблице: **order_id**
```sql
WITH
subquery AS (SELECT order_id
             FROM   user_actions
             WHERE  action = 'cancel_order')
SELECT order_id
FROM user_actions
WHERE order_id NOT IN (SELECT *
                       FROM   subquery)
ORDER BY order_id 
LIMIT 1000
```

**Задание №8**

Используя данные из таблицы **user_actions**, рассчитайте, сколько заказов сделал каждый пользователь и отразите это в столбце **orders_count**.

В отдельном столбце **orders_avg** напротив каждого пользователя укажите среднее число заказов всех пользователей, округлив его до двух знаков после запятой.

Также для каждого пользователя посчитайте отклонение числа заказов от среднего значения. Отклонение считайте так: число заказов «минус» округлённое среднее значение. Колонку с отклонением назовите **orders_diff**.

Результат отсортируйте по возрастанию **id** пользователя. Добавьте в запрос оператор **LIMIT** и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: **user_id**, **orders_count**, **orders_avg**, **orders_diff**

```sql
WITH
subquery_1 AS (SELECT user_id,
                      count(order_id) AS orders_count
                      FROM   user_actions
                      WHERE  action = 'create_order'
                      GROUP BY user_id)
SELECT user_id,
       orders_count,
       (SELECT ROUND(AVG(orders_count), 2)
        FROM   subquery_1) AS orders_avg, orders_count - ROUND((SELECT AVG(orders_count)
                                                                FROM   subquery_1), 2) AS orders_diff
FROM subquery_1
ORDER BY user_id 
LIMIT 1000
```

**Задание №9**

Назначьте скидку 15% на товары, цена которых превышает среднюю цену на все товары на 50 и более рублей, а также скидку 10% на товары, цена которых ниже средней на 50 и более рублей. Цену остальных товаров внутри диапазона (среднее - 50; среднее + 50) оставьте без изменений. При расчёте средней цены, округлите её до двух знаков после запятой.

Выведите информацию о всех товарах с указанием старой и новой цены. Колонку с новой ценой назовите **new_price**.

Результат отсортируйте сначала по убыванию прежней цены в колонке **price**, затем по возрастанию **id** товара.

Поля в результирующей таблице: **product_id**, **name**, **price**, **new_price**
```sql
WItH 
subquery_1 AS (SELECT ROUND(AVG(price), 2) AS avg_price
               FROM products)
SELECT product_id,
       name,
       price,
       CASE 
       WHEN price >= (SELECT avg_price
                      FROM   subquery_1) + 50 THEN price * 0.85 WHEN price <= (SELECT avg_price
                                                                               FROM   subquery_1) - 50 THEN price * 0.9 ELSE price END AS new_price
FROM products
ORDER BY price DESC, product_id
```

**Задание №10**

Выясните, есть ли в таблице **courier_actions** такие заказы, которые были приняты курьерами, но не были созданы пользователями. Посчитайте количество таких заказов.

Колонку с числом заказов назовите **orders_count**.

Поле в результирующей таблице: **orders_count**


```sql
WITH
subquery_1 AS (SELECT order_id
               FROM   user_actions
               WHERE  action = 'create_order')
SELECT COUNT(order_id NOT IN(SELECT order_id
                             FROM subquery_1)) AS orders_count
FROM   courier_actions
WHERE  order_id NOT IN(SELECT order_id
                       FROM   subquery_1)
```

**Задание №11**

Выясните, есть ли в таблице **courier_actions** такие заказы, которые были приняты курьерами, но не были доставлены пользователям. Посчитайте количество таких заказов.

Колонку с числом заказов назовите **orders_count**.

Поле в результирующей таблице: **orders_count**

```sql
SELECT COUNT(order_id) AS orders_count
FROM courier_actions
WHERE order_id NOT IN (SELECT order_id
                       FROM   courier_actions
                       WHERE  action = 'deliver_order')
```

**Задание №12**

Определите количество отменённых заказов в таблице **courier_actions** и выясните, есть ли в этой таблице такие заказы, которые были отменены пользователями, но при этом всё равно были доставлены. Посчитайте количество таких заказов.

Колонку с отменёнными заказами назовите **orders_canceled**. Колонку с отменёнными, но доставленными заказами назовите **orders_canceled_and_delivered**. 

Поля в результирующей таблице: **orders_canceled**, **orders_canceled_and_delivered**
```sql
WITH 
subquery_1 AS (SELECT COUNT(order_id) AS orders_canceled
               FROM user_actions
               WHERE action = 'cancel_order')
SELECT (SELECT orders_canceled FROM subquery_1), 
        COUNT(order_id) FILTER(WHERE  action = 'deliver_order') NOT IN (SELECT order_id
                                                                        FROM   user_actions)::int AS orders_canceled_and_delivered
FROM courier_actions 
LIMIT 100
```

**Задание №13**

По таблицам **courier_actions** и **user_actions** снова определите число недоставленных заказов и среди них посчитайте количество отменённых заказов и количество заказов, которые не были отменены (и соответственно, пока ещё не были доставлены).

Колонку с недоставленными заказами назовите **orders_undelivered**, колонку с отменёнными заказами назовите **orders_canceled**, колонку с заказами «в пути» назовите **orders_in_process**.

Поля в результирующей таблице: **orders_undelivered**, **orders_canceled**, **orders_in_process**
```sql
SELECT (SELECT COUNT(order_id) FILTER (WHERE action = 'create_order')  FROM user_actions) - 
       (SELECT COUNT(order_id) FILTER (WHERE action = 'deliver_order') FROM courier_actions) AS orders_undelivered, 
       (SELECT COUNT(order_id) FILTER(WHERE action = 'cancel_order')   FROM user_actions) AS orders_canceled, 
       (SELECT COUNT(DISTINCT order_id) - COUNT(order_id) FILTER(WHERE action != 'cancel_order')
FROM user_actions) AS orders_in_process
```

**Задание №14**

Отберите из таблицы **users** пользователей мужского пола, которые старше всех пользователей женского пола.

Выведите две колонки: **id** пользователя и дату рождения. Результат отсортируйте по возрастанию **id** пользователя.

Поля в результирующей таблице: **user_id**, **birth_date**
```sql
WITH
subquery AS (SELECT MIN(birth_date) FILTER(WHERE sex = 'female') AS min_female
             FROM users)
SELECT user_id,
       birth_date
FROM users
WHERE sex = 'male' AND birth_date < (SELECT min_female
                                     FROM   subquery)
ORDER BY user_id
```

**Задание №15**

Выведите **id** и содержимое 100 последних доставленных заказов из таблицы **orders**.

Содержимым заказов считаются списки с **id** входящих в заказ товаров. Результат отсортируйте по возрастанию **id** заказа.

Поля в результирующей таблице: **order_id**, **product_ids**
```sql
SELECT order_id,
       product_ids
FROM   orders
WHERE  order_id IN (SELECT order_id
                    FROM courier_actions
                    WHERE action = 'deliver_order'
                    ORDER BY time DESC 
                    LIMIT 100)
ORDER BY order_id
LIMIT 100
```

**Задание №16**

Из таблицы **couriers** выведите всю информацию о курьерах, которые в сентябре 2022 года доставили 30 и более заказов. Результат отсортируйте по возрастанию **id** курьера.

Поля в результирующей таблице: **courier_id**, **birth_date**, **sex**
```sql
SELECT courier_id,
       birth_date,
       sex
FROM couriers
WHERE courier_id IN  (SELECT courier_id
                      FROM  courier_actions
                      WHERE action = 'deliver_order' AND time BETWEEN '09-01-2022' AND '10-01-2022'
                      GROUP BY courier_id HAVING COUNT (order_id) >= 30)
ORDER BY courier_id 
LIMIT 100
```

**Задание №17**

Рассчитайте средний размер заказов, отменённых пользователями мужского пола.

Средний размер заказа округлите до трёх знаков после запятой. Колонку со значением назовите **avg_order_size**.

Поле в результирующей таблице: **avg_order_size**
```sql
SELECT ROUND(AVG(ARRAY_LENGTH(product_ids, 1)), 3) AS avg_order_size
FROM orders
WHERE order_id IN (SELECT order_id
                   FROM   user_actions
                   WHERE  action = 'cancel_order' AND user_id IN (SELECT user_id
                                                                  FROM   users
                                                                  WHERE  sex = 'male'))
```

**Задание №18**

Посчитайте возраст каждого пользователя в таблице **users**.

Возраст измерьте числом полных лет, как мы делали в прошлых уроках. Возраст считайте относительно последней даты в таблице **user_actions**.

Для тех пользователей, у которых в таблице **users** не указана дата рождения, укажите среднее значение возраста всех остальных пользователей, округлённое до целого числа.

Колонку с возрастом назовите **age**. В результат включите колонки с **id** пользователя и возрастом. Отсортируйте полученный результат по возрастанию **id** пользователя.

Поля в результирующей таблице: **user_id**, **age**
```sql
WITH 
subquery AS (SELECT user_id,
                    date_part('year', AGE((SELECT MAX(TIME)
                                           FROM   user_actions), birth_date)) AS age
             FROM   users)
SELECT user_id,
       COALESCE(age, (SELECT ROUND(AVG(age))
                      FROM   subquery))::integer as age
FROM subquery
ORDER BY user_id
```

**Задание №19**

Для каждого заказа, в котором больше 5 товаров, рассчитайте время, затраченное на его доставку. 

В результат включите id заказа, время принятия заказа курьером, время доставки заказа и время, затраченное на доставку. Новые колонки назовите соответственно **time_accepted**, **time_delivered** и **delivery_time**.

В расчётах учитывайте только неотменённые заказы. Время, затраченное на доставку, выразите в минутах, округлив значения до целого числа. Результат отсортируйте по возрастанию **id** заказа.

Поля в результирующей таблице: **order_id**, **time_accepted**, **time_delivered** и **delivery_time**
```sql
WITH
subquery AS (SELECT order_id,
                    array_length(product_ids, 1)
             FROM   orders
             WHERE  array_length(product_ids, 1) > 5 AND order_id NOT IN (SELECT order_id
                                                                          FROM   user_actions
                                                                          WHERE  action = 'cancel_order'))
SELECT order_id,
       MIN(time) AS time_accepted,
       MAX(time) AS time_delivered,
       extract(epoch
FROM   ((MAX(time) - MIN(time)) / 60)) ::int AS delivery_time
FROM   courier_actions
WHERE  order_id IN (SELECT order_id
                    FROM   subquery)
GROUP BY order_id
ORDER BY order_id
```

**Задание №20**

Для каждой даты в таблице **user_actions** посчитайте количество первых заказов, совершённых пользователями.

Первыми заказами будем считать заказы, которые пользователи сделали в нашем сервисе впервые. В расчётах учитывайте только неотменённые заказы.

В результат включите две колонки: дату и количество первых заказов в эту дату. Колонку с датами назовите **date**, а колонку с первыми заказами — **first_orders**.

Результат отсортируйте по возрастанию даты.

Поля в результирующей таблице: **date**, **first_orders**
```sql
WITH 
subquery_1 AS (SELECT user_id,
                      date(MIN(time)) AS date
               FROM   user_actions
               WHERE  order_id NOT IN (SELECT order_id
                                       FROM   user_actions
                                       WHERE  action = 'cancel_order')
               GROUP BY user_id)
SELECT COUNT(user_id) AS first_orders,
       date
FROM subquery_1
GROUP BY date
ORDER BY date
```

**Задание №21**


Выберите все колонки из таблицы **orders** и дополнительно в качестве последней колонки укажите функцию **unnest**, применённую к колонке **product_ids**. Эту последнюю колонку назовите **product_id**. Больше ничего с данными делать не нужно.

Добавьте в запрос оператор **LIMIT** и выведите только первые 100 записей результирующей таблицы.

Поля в результирующей таблице: **creation_time**, **order_id**, **product_ids**, **product_id**

Посмотрите на результат работы функции **unnest** и постарайтесь разобраться, что произошло с исходной таблицей.
```sql
SELECT creation_time,
       order_id,
       product_ids,
       UNNEST(product_ids) AS product_id
FROM orders 
LIMIT 100
```

**Задание №22**


Используя функцию **unnest**, определите 10 самых популярных товаров в таблице **orders**.

Самыми популярными товарами будем считать те, которые встречались в заказах чаще всего. Если товар встречается в одном заказе несколько раз (когда было куплено несколько единиц товара), это тоже учитывается при подсчёте. Учитывайте только неотменённые заказы.

Выведите **id** товаров и то, сколько раз они встречались в заказах (то есть сколько раз были куплены). Новую колонку с количеством покупок товаров назовите **times_purchased**.

Результат отсортируйте по возрастанию **id** товара.

Поля в результирующей таблице: **product_id**, **times_purchased**
```sql
WITH
subquery_1 AS (SELECT UNNEST(product_ids) AS product_id
               FROM   orders
               WHERE  order_id NOT IN (SELECT order_id
                                       FROM   user_actions
                                       WHERE  action = 'cancel_order')), subquery_2 AS (SELECT product_id,
                                                                                        COUNT(product_id) AS times_purchased
                                                                                        FROM subquery_1
                                                                                        GROUP BY product_id
                                                                                        ORDER BY times_purchased DESC 
                                                                                        LIMIT 10)
SELECT *
FROM subquery_2
ORDER BY product_id
```

**Задание №23**

Из таблицы **orders** выведите **id** и содержимое заказов, которые включают хотя бы один из пяти самых дорогих товаров, доступных в нашем сервисе.

Результат отсортируйте по возрастанию **id** заказа.

Поля в результирующей таблице: **order_id**, **product_ids**
```sql
WITH 
subquery_1 AS (SELECT product_id,
                      price
                    FROM products
                    ORDER BY price DESC 
                    LIMIT 5),
    
subquery_2 as (SELECT order_id,
                      product_ids,
                      UNNEST(product_ids) AS product_id
               FROM   orders)
SELECT DISTINCT order_id,
                product_ids
FROM subquery_2
WHERE product_id IN (SELECT product_id
                     FROM   subquery_1)
ORDER BY order_id
```
</details>

<details>
  <summary>Join</summary>

# Join

**Задание №1**

Объедините таблицы **user_actions** и **users** по ключу **user_id**. В результат включите две колонки с **user_id** из обеих таблиц. Эти две колонки назовите соответственно **user_id_left** и **user_id_right**. Также в результат включите колонки **order_id**, **time**, **action**, **sex**, **birth_date**. Отсортируйте получившуюся таблицу по возрастанию **id** пользователя (в любой из двух колонок с **id**).

Поля в результирующей таблице: **user_id_left**, **user_id_right**,  **order_id**, **time**, **action**, **sex**, **birth_date**

```sql
-- выводим необходимые по условию колонки и переименовываем user_id из наших таблиц
SELECT a.user_id AS user_id_left,
       b.user_id AS user_id_right,
       order_id,
       time,
       action,
       sex,
       birth_date
-- далее объединяем таблицы user_actions и users по ключу user_id
FROM user_actions a JOIN users b
ON a.user_id = b.user_id
ORDER BY user_id_left
-- сортируем по возрастанию, по user_id таблицы user_actions
```

**Задание №2**

А теперь попробуйте немного переписать запрос из прошлого задания и посчитать количество уникальных **id** в объединённой таблице. То есть снова объедините таблицы, но в этот раз просто посчитайте уникальные **user_id** в одной из колонок с **id**. Выведите это количество в качестве результата. Колонку с посчитанным значением назовите **users_count**.

Поле в результирующей таблице: **users_count**

После того как решите задачу, сравните полученное значение с количеством уникальных пользователей в таблицах **users** и **user_actions**, которое мы посчитали на прошлом шаге. С каким значением оно совпадает?

```sql
-- подсчитываем количество уникальных пользователей в колонке user_id из таблицы user_actions
SELECT COUNT(DISTINCT a.user_id) AS users_count
-- далее объединяем таблицы user_actions и users по ключу user_id
FROM user_actions a JOIN users b
    ON a.user_id = b.user_id
-- полученное значение совпадает с количеством уникаьных пользователей в таблице users,
-- это означает наличие дубликатов ключей user_id в таблице user_actions
```

**Задание №3**

С помощью **LEFT JOIN** объедините таблицы **user_actions** и **users** по ключу **user_id**. Обратите внимание на порядок таблиц — слева **users_actions**, справа **users**. В результат включите две колонки с **user_id** из обеих таблиц. Эти две колонки назовите соответственно **user_id_left** и **user_id_right**. Также в результат включите колонки **order_id**, **time**, **action**, **sex**, **birth_date**. Отсортируйте получившуюся таблицу по возрастанию **id** пользователя (в колонке из левой таблицы).

Поля в результирующей таблице: **user_id_left**, **user_id_right**,  **order_id**, **time**, **action**, **sex**, **birth_date**

После того как решите задачу, обратите внимание на колонки с **user_id**. Нет ли в какой-то из них пропущенных значений?

```sql
-- выводим необходимые по условию колонки и переименовываем user_id из наших таблиц
SELECT a.user_id AS user_id_left,
       b.user_id AS user_id_right,
       order_id,
       time,
       action,
       sex,
       birth_date
-- далее объединяем таблицы user_actions и users по ключу user_id
FROM user_actions AS a
LEFT JOIN users AS b USING (user_id)
-- сортируем по возрастанию user_id, по левой таблице(user_actions)
ORDER BY user_id_left
```

**Задание №4**

Теперь снова попробуйте немного переписать запрос из прошлого задания и посчитайте количество уникальных **id** в колонке **user_id**, пришедшей из левой таблицы **user_actions**. Выведите это количество в качестве результата. Колонку с посчитанным значением назовите **users_count**.

Поле в результирующей таблице: **users_count**

После того как решите задачу, сравните полученное значение с количеством уникальных пользователей в таблицах users и **user_actions**. С каким значением оно совпало в этот раз?

```sql
-- подсчитываем количество уникальных пользователей в колонке user_id из таблицы user_actions
SELECT COUNT(DISTINCT a.user_id) AS users_count
-- далее объединяем таблицы user_actions и users по ключу user_id
FROM user_actions AS a
    LEFT JOIN users AS b USING (user_id)
-- полученное значение совпадает с количеством уникальных пользователей в таблице users
```

**Задание №5**

Возьмите запрос из задания 3, где вы объединяли таблицы **user_actions** и **users** с помощью **LEFT JOIN**, добавьте к запросу оператор **WHERE** и исключите **NULL** значения в колонке **user_id** из правой таблицы. Включите в результат все те же колонки и отсортируйте получившуюся таблицу по возрастанию **id** пользователя в колонке из левой таблицы.

Поля в результирующей таблице: **user_id_left**, **user_id_right**,  **order_id**, **time**, **action**, **sex**, **birth_date**

После того как решите задачу, попробуйте сдать это же решение в первом задании — сработает или нет? Подумайте, какой **JOIN** мы сейчас получили после всех манипуляций с результатом. Заодно можете посчитать число уникальных **user_id** в запросе из этого задания, чтобы расставить все точки над **«i»**.

```sql
-- выводим необходимые по условию колонки и переименовываем user_id из наших таблиц
SELECT a.user_id AS user_id_left,
       b.user_id AS user_id_right,
       order_id,
       time,
       action,
       sex,
       birth_date
       -- далее объединяем таблицы user_actions и users по ключу user_id
FROM user_actions AS a
    LEFT JOIN users AS b USING (user_id)
-- для колонки user_id из правой таблицы исключаем значения равные нулю
WHERE b.user_id != 0
-- сортируем по возрастанию user_id, по левой таблице(user_actions)
ORDER BY user_id_left
-- по итогу получаем ту же таблицу чо и при INNER JOIN
```

**Задание №6**

С помощью **FULL JOIN** объедините по ключу **birth_date** таблицы, полученные в результате вышеуказанных запросов (то есть объедините друг с другом два подзапроса). Не нужно изменять их, просто добавьте нужный **JOIN**.

В результат включите две колонки с **birth_date** из обеих таблиц. Эти две колонки назовите соответственно **users_birth_date** и **couriers_birth_date**. Также включите в результат колонки с числом пользователей и курьеров — **users_count** и **couriers_count**.

Отсортируйте получившуюся таблицу сначала по колонке **users_birth_date** по возрастанию, затем по колонке **couriers_birth_date** — тоже по возрастанию.

Поля в результирующей таблице: **users_birth_date**, **users_count**,  **couriers_birth_date**, **couriers_count**

После того как решите задачу, изучите полученную таблицу в Redash. Обратите внимание на пропущенные значения в колонках с датами рождения курьеров и пользователей. Подтвердилось ли наше предположение?

```sql
-- 1. создаем временные таблицы t1 и t2, группируем по колонке birth_date и считаем,
-- сколько пользователей/курьеров родились в каждый из дней
WITH 
t1 AS (SELECT birth_date,
       COUNT(user_id) AS users_count
       FROM users
       WHERE  birth_date IS NOT NULL
       GROUP BY birth_date), t2 AS (SELECT birth_date,
                                           COUNT(courier_id) AS couriers_count
                                    FROM couriers
                                    WHERE birth_date IS NOT NULL
                                    GROUP BY birth_date)
-- 3. выводим необходимые по условию колонки и переименовываем birth_date из наших таблиц
SELECT t1.birth_date AS users_birth_date,
       users_count,
       t2.birth_date AS couriers_birth_date,
       couriers_count
       -- 2. далее при помощи FULL JOIN объединяем наши таблицы t1 и t2 по ключу birth_date
FROM t1 FULL JOIN t2 USING(birth_date)
-- 4. сортируем по users_birth_date по возрастанию, затем по колонке couriers_birth_date — тоже по возрастанию
ORDER BY users_birth_date, couriers_birth_date
```

**Задание №7**

Объедините два следующих запроса друг с другом так, чтобы на выходе получился набор уникальных дат из таблиц **users** и **couriers**:

```sql
SELECT birth_date
FROM users
WHERE birth_date IS NOT NULL


SELECT birth_date
FROM couriers
WHERE birth_date IS NOT NULL
```

Поместите в подзапрос полученный после объединения набор дат и посчитайте их количество. Колонку с числом дат назовите **dates_count**.

Поле в результирующей таблице: **dates_count**

После того как решите задачу, сравните полученное число дат с количеством строк в таблице, которую мы получили в прошлом задании. Совпали ли эти значения?

```sql
-- создаем подзапрос, где объединяем записи нащих столбцов
WITH
t1 AS (SELECT birth_date
       FROM   users
       WHERE  birth_date IS NOT NULL
-- объединяет записи из двух запросов в один общий
       UNION
    
SELECT birth_date
       FROM   couriers
       WHERE  birth_date IS NOT NULL)
-- считаем количество записей в получившейся таблице
SELECT COUNT(birth_date) AS dates_count
FROM   t1
```

**Задание №8**

Из таблицы **users** отберите **id** первых 100 пользователей (просто выберите первые 100 записей, используя простой **LIMIT**) и с помощью **CROSS JOIN** объедините их со всеми наименованиями товаров из таблицы **products**. Выведите две колонки — **id** пользователя и наименование товара. Результат отсортируйте сначала по возрастанию **id** пользователя, затем по имени товара — тоже по возрастанию.

Поля в результирующей таблице: **user_id**, **name**

После того как решите задачу, посмотрите сколько было изначально строк в каждой таблице и сравните с тем, сколько их получилось после объединения.

```sql
-- 1. отбираем первых 100 пользователей
WITH
t1 AS (SELECT user_id
       FROM   users 
       LIMIT 100)
-- 3. отбираем интересующие нас колонки
SELECT user_id,
       name
-- 2. объединяем наш отфильтрованный подзапрос с таблицей products через CROSS JOIN
FROM   t1 CROSS JOIN products
-- сортируем по возрастанию, сначала user_id, после name
ORDER BY user_id, name
```

**Задание №9**

Для начала объедините таблицы **user_actions** и **orders** — это вы уже умеете делать. В качестве ключа используйте поле **order_id**. Выведите **id** пользователей и заказов, а также список товаров в заказе. Отсортируйте таблицу по **id** пользователя по возрастанию, затем по **id** заказа — тоже по возрастанию.

Добавьте в запрос оператор **LIMIT** и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: **user_id**, **order_id**, **product_ids**

```sql
-- 2. отбираем интересующие нас колонки
SELECT user_id,
       order_id,
       product_ids
-- 1. далее, для объединения таблиц user_actions и orders выбираем INNER JOIN,
-- который из двух таблиц уберет все строки, которые не прошли проверку на соответствие условию
FROM   user_actions JOIN orders USING(order_id)
-- 3. сортируем по возрастанию, сначала user_id, после order_id
ORDER BY user_id, order_id 
LIMIT 1000
```

**Задание №10**

Снова объедините таблицы **user_actions** и **orders**, но теперь оставьте только уникальные неотменённые заказы (мы делали похожий запрос на прошлом уроке). Остальные условия задачи те же: вывести **id** пользователей и заказов, а также список товаров в заказе. Отсортируйте таблицу по **id** пользователя по возрастанию, затем по **id** заказа — тоже по возрастанию.

Добавьте в запрос оператор **LIMIT** и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: **user_id**, **order_id**, **product_ids**

```sql
-- выводим необходимые по условию колонки
SELECT order_id,
       user_id,
       product_ids
/*создает список всех заказов, которые не были отменены и выбирает только те `order_id`,
которые нет в этом списке и объединяем с таблицей orders по LEFT JOIN*/
FROM   (SELECT DISTINCT order_id,
                        user_id
        FROM   user_actions
        WHERE  order_id NOT IN (SELECT DISTINCT order_id
                                FROM   user_actions
                                WHERE  action = 'cancel_order')) t1
    LEFT JOIN orders using(order_id)
-- сортируем по возрастанию, сначала user_id, после order_id
ORDER BY user_id, order_id 
LIMIT 1000
```

**Задание №11**

Используя запрос из предыдущего задания, посчитайте, сколько в среднем товаров заказывает каждый пользователь. Выведите **id** пользователя и среднее количество товаров в заказе. Среднее значение округлите до двух знаков после запятой. Колонку посчитанными значениями назовите **avg_order_size**. Результат выполнения запроса отсортируйте по возрастанию **id** пользователя. 

Добавьте в запрос оператор **LIMIT** и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: **user_id**, **avg_order_size**



```sql
/* при помощи array_length подсчитываем количество товаров в заказе
   и считаем среднее для каждого пользователя*/
SELECT user_id,
       round(avg(array_length(product_ids, 1)), 2) AS avg_order_size
/*создает список всех заказов, которые не были отменены и выбирает только те `order_id`,
          которые нет в этом списке и объединяем с таблицей orders по LEFT JOIN*/
FROM   (SELECT DISTINCT order_id,
                        user_id
        FROM   user_actions
        WHERE  order_id NOT IN (SELECT DISTINCT order_id
                                FROM   user_actions
                                WHERE  action = 'cancel_order')) t1
    LEFT JOIN orders USING(order_id)
-- производим группировку данных по id пользователей
GROUP BY user_id
-- сортируем по возрастанию, сначала user_id, после order_id
ORDER BY user_id 
LIMIT 1000
```

**Задание №12**

Для начала к таблице с заказами (**orders**) примените функцию **unnest**, как мы делали в прошлом уроке. Колонку с **id** товаров назовите **product_id**. Затем к образовавшейся расширенной таблице по ключу **product_id** добавьте информацию о ценах на товары (из таблицы **products**). Должна получиться таблица с заказами, товарами внутри каждого заказа и ценами на эти товары. Выведите колонки с **id** заказа, **id** товара и ценой товара. Результат отсортируйте сначала по возрастанию **id** заказа, затем по возрастанию **id** товара.

Добавьте в запрос оператор **LIMIT** и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: **order_id**, **product_id, price**

```sql
-- создаем подзапрос, где разверноем наш массив с продуктами в
WITH
t1 AS (SELECT order_id,
       UNNEST(product_ids) as product_id
       FROM   orders)
-- выводим необходимые по условию колонки
SELECT order_id,
       product_id,
       price
FROM   t1
    LEFT JOIN products USING(product_id)
-- сортируем по возрастанию, сначала order_id, после product_id
ORDER BY order_id, product_id 
LIMIT 1000
```

**Задание №13**

Используя запрос из предыдущего задания, рассчитайте суммарную стоимость каждого заказа. Выведите колонки с **id** заказов и их стоимостью. Колонку со стоимостью заказа назовите **order_price**. Результат отсортируйте по возрастанию **id** заказа.

Добавьте в запрос оператор **LIMIT** и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: **order_id**, **order_price**

```sql
-- создаем подзапрос, где разверноем наш массив с продуктами
WITH t1 AS (SELECT order_id,
            UNNEST(product_ids) AS product_id
            FROM   orders)
-- выводим необходимые по условию колонки и подсчитываем для сгруппированных id заказа сумму
SELECT order_id,
       sum(price) AS order_price
FROM   t1
    LEFT JOIN products USING(product_id)
-- группируем по id заказов
GROUP BY order_id
-- сортируем по возрастанию, по order_id
ORDER BY order_id 
LIMIT 1000
```

**Задание №14**

Вот теперь у нас есть всё необходимое, чтобы сделать наш первый серьёзный аналитический запрос и посчитать разные пользовательские метрики!

Давайте объединим в один запрос данные о количестве товаров в заказах наших пользователей с информацией о стоимости каждого заказа, а затем рассчитаем несколько полезных показателей.

Задача:

Объедините запрос из предыдущего задания с частью запроса, который вы составили в задаче 11, то есть объедините запрос со стоимостью заказов с запросом, в котором вы считали размер каждого заказа из таблицы **user_actions**.

На основе объединённой таблицы для каждого пользователя рассчитайте следующие показатели:

общее число заказов — колонку назовите **orders_count**
среднее количество товаров в заказе — **avg_order_size**
суммарную стоимость всех покупок — **sum_order_value**
среднюю стоимость заказа — **avg_order_value**
минимальную стоимость заказа — **min_order_value**
максимальную стоимость заказа — **max_order_value**
Полученный результат отсортируйте по возрастанию **id** пользователя.

Добавьте в запрос оператор **LIMIT** и выведите только первые 1000 строк результирующей таблицы.

Помните, что в расчётах мы по-прежнему учитываем только неотменённые заказы. При расчёте средних значений, округляйте их до двух знаков после запятой.

Поля в результирующей таблице: 

**user_id**, **orders_count**, **avg_order_size**, **sum_order_value**, **avg_order_value**, **min_order_value**, **max_order_value**

```sql
WITH
t3 AS (SELECT order_id,
              sum(price) AS order_price
       FROM   (SELECT order_id,
                      UNNEST(product_ids) AS product_id
               FROM   orders) t1
               LEFT JOIN products USING(product_id)
-- группируем по id заказов
               GROUP BY order_id), t4 AS (SELECT order_id,
                                                 user_id,
                                                 product_ids,
                                                 ROUND(avg(ARRAY_LENGTH(product_ids, 1)), 2) AS avg_order_size
                                          FROM   (SELECT DISTINCT order_id,
                                                                  user_id
                                                   FROM   user_actions
                                                   WHERE  order_id not in (SELECT DISTINCT order_id
                                                                           FROM   user_actions
                                                                           WHERE  action = 'cancel_order')) t2
                                                                           LEFT JOIN orders using(order_id)
-- производим группировку данных по id пользователей
                                                                           GROUP BY user_id, order_id, product_ids)
SELECT user_id,
       ROUNF(AVG(ARRAY_LENGTH(product_ids, 1)), 2) AS avg_order_size,
       COUNT(DISTINCT order_id) AS orders_count,
       SUM(order_price) AS sum_order_value,
       ROUND(AVG(order_price), 2) AS avg_order_value,
       MON(order_price) AS min_order_value,
       MAX(order_price) AS max_order_value

FROM   t3 JOIN t4 USING(order_id)
GROUP BY user_id
ORDER BY user_id 
LIMIT 1000
```

**Задание №15**

По данным таблиц **orders**, **products** и **user_actions** посчитайте ежедневную выручку сервиса. Под выручкой будем понимать стоимость всех реализованных товаров, содержащихся в заказах.

Колонку с датой назовите **date**, а колонку со значением выручки — **revenue**.

В расчётах учитывайте только неотменённые заказы.

Результат отсортируйте по возрастанию даты.

Поля в результирующей таблице: **date**, **revenue**

```sql
-- выводим необходимые по условию колонки, преобразуем creation_time в формат даты и находим сумму цен
SELECT CREATION_TIME::DATE AS date,
       SUM(price)::DECIMAL AS revenue
-- создаем подзапрос где разворачиваем массив с наименованием продуктов и фильтруем отмененные заказы
FROM   (SELECT order_id,
               creation_time,
               UNNEST(product_ids) AS product_id
        FROM   orders
        WHERE  order_id NOT IN (SELECT order_id
                                FROM   user_actions
                                WHERE  action = 'cancel_order')) t1JOIN 
    
-- соединяем наши таблицы по id продукта
        (SELECT price,
                product_id
         FROM   products)t2 USING(product_id)
-- группируем и сортируем по дате
         GROUP BY date
         ORDER BY date
```

**Задание №16**

По таблицам **courier_actions** , **orders** и **products** определите 10 самых популярных товаров, доставленных в сентябре 2022 года.

Самыми популярными товарами будем считать те, которые встречались в заказах чаще всего. Если товар встречается в одном заказе несколько раз (было куплено несколько единиц товара), то при подсчёте учитываем только одну единицу товара.

Выведите наименования товаров и сколько раз они встречались в заказах. Новую колонку с количеством покупок товара назовите **times_purchased**. 

Поля в результирующей таблице: **name**, **times_purchased**

```sql
/*создаем подзапрос где расскрываем массив с продуктами в отдельные значения и производим фильтрацию
   по временному периоду и доставленным заказам*/
WITH
t1 AS (SELECT DISTINCT UNNEST (product_ids) AS product_id
              creation_time::date,
              order_id
       FROM   orders
       WHERE  order_id IN (SELECT order_id
                           FROM   courier_actions
                           WHERE  action = 'deliver_order'
                           AND date_part ('year', time) = 2022
                           AND date_part ('month', time) = 9)), t2 AS (SELECT *
                                                                       FROM   t1
                                                                       LEFT JOIN products USING(product_id))
    
-- отбираем необходимые колонки и подсчитываем количество для каждого товара
SELECT name,
       COUNT(product_id)::int AS times_purchased
FROM   t2
GROUP BY name
-- сортируем по количеству товара, по убыванию
ORDER BY times_purchased DESC
LIMIT 10
-- ограничиваем запрос до 10 строкlimit 10
```

**Задание №17**

Возьмите запрос, составленный на одном из прошлых уроков, и подтяните в него из таблицы users данные о поле пользователей таким образом, чтобы все пользователи из таблицы **user_actions** остались в результате. Затем посчитайте среднее значение **cancel_rate** для каждого пола, округлив его до трёх знаков после запятой. Колонку с посчитанным средним значением назовите **avg_cancel_rate**.

Помните про отсутствие информации о поле некоторых пользователей после **join**, так как не все пользователи из таблицы **user_action** есть в таблице **users**. Для этой группы тоже посчитайте **cancel_rate** и в результирующей таблице для пустого значения в колонке с полом укажите **‘unknown’** (без кавычек). Возможно, для этого придётся вспомнить, как работает **COALESCE**.

Результат отсортируйте по колонке с полом пользователя по возрастанию.

Поля в результирующей таблице: **sex**, **avg_cancel_rate**

```sql
-- в данном подзапросе посчитаем долю отмененных заказов для каждого пользователя
WITH
t1 AS (SELECT user_id,
              ROUND(COUNT(DISTINCT order_id) FILTER (WHERE action = 'cancel_order')::decimal / COUNT(DISTINCT order_id),3) AS cancel_rate,
              COUNT(DISTINCT order_id) AS orders_count
    
        FROM   user_actions
        GROUP BY user_id), t2 AS (SELECT *
-- объеденим 2 таблицы
                                  FROM   users
                                  RIGHT JOIN t1 USING(user_id))
    
/*выберем требуемые колонки, посчитаем среднее значение отмененных заказов дл каждого пола,
   а для тех строк по которым нет данных присвоим им 'unknown'*/
    
SELECT COALESCE(sex, 'unknown') AS sex,
       ROUND(AVG(cancel_rate), 3) AS avg_cancel_rate
FROM   t2
-- сгруппируем итоговую таблицу по полу пользователей
GROUP BY sex
-- отсортируем по возрастанию пола
ORDER BY sex
```

**Задание №18**

По таблицам **orders** и **courier_actions** определите **id** десяти заказов, которые доставляли дольше всего.

Поле в результирующей таблице: **order_id**

```sql
/*фильтруем таблицу с действиями курьеров, берем только доставленные заказы
   (в time будет отображаться врея доставки)*/
WITH
t1 AS (SELECT *
       FROM   courier_actions
       WHERE  action = 'deliver_order'),
/*присоединяем колонку с действиями и фильтруем по созданным заказам
   (теперь creation_time это время создания заказа)*/
t2 AS (SELECT creation_time,
              order_id
       FROM   orders JOIN courier_actions USING(order_id)
WHERE  action = 'accept_order'),
/* объединяем наши обработанные таблицы и производим вычисления с последующей фильтрацией*/  
t3 AS (SELECT order_id,
              time - creation_time AS long_time
       FROM   t1 JOIN t2 USING(order_id)
       ORDER BY long_time DESC)
       SELECT order_id
       FROM   t3 
       LIMIT 10
```

**Задание №19**

Произведите замену списков с **id** товаров из таблицы orders на списки с наименованиями товаров. Наименования возьмите из таблицы **products**. Колонку с новыми списками наименований назовите **product_names**. 

Добавьте в запрос оператор **LIMIT** и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: **order_id**, **product_names**

```sql
-- разворачиваем наш список с продуктами, а во втором подзапросе присоединяем таблицу с наименованием продуктов
WITH
t1 AS (SELECT order_id,
               UNNEST(product_ids) AS product_id
       FROM   orders), t2 AS (SELECT *
                              FROM   t1
                              LEFT JOIN products USING(product_id))
-- сворачивем продукты из нашего заказа в список в соответсвии с id заказа
SELECT order_id,
       ARRAY_AGG(name) AS product_names
FROM   t2
GROUP BY order_id 
LIMIT 1000
```

**Задание №20**

Выясните, кто заказывал и доставлял самые большие заказы. Самыми большими считайте заказы с наибольшим числом товаров.

Выведите **id** заказа, **id** пользователя и **id** курьера. Также в отдельных колонках укажите возраст пользователя и возраст курьера. Возраст измерьте числом полных лет, как мы делали в прошлых уроках. Считайте его относительно последней даты в таблице **user_actions** — как для пользователей, так и для курьеров. Колонки с возрастом назовите user_age и **courier_age**. Результат отсортируйте по возрастанию **id** заказа.

Поля в результирующей таблице: **order_id**, **user_id**, **user_age**, **courier_id**, **courier_age**

```sql
-- подсчитываем и отбираем, заказы с самым большим количеством значений в массиве
WITH 
t1 AS 
(SELECT order_id,
        ARRAY_LENGTH(product_ids, 1) AS product_id
FROM   orders
ORDER BY product_id DESC 
LIMIT 5),
-- объединяем таблицы с нужными нам колонками
t2 AS (SELECT *
       FROM   t1
       LEFT JOIN (SELECT order_id,
                         courier_id
                  FROM   courier_actions
                  WHERE  action = 'deliver_order') t3 USING(order_id)), t4 AS (SELECT *
                                                                               FROM   t2
                                                                               LEFT JOIN couriers USING(courier_id)), 
t5 AS (SELECT courier_id,
              order_id,
              t4.birth_date as courier_birth_date,
              user_id,
              t6.birth_date as user_birth_date
       FROM   t4
       LEFT JOIN (SELECT *
                  FROM   user_actions
                  LEFT JOIN users USING(user_id)) AS t6 USING(order_id)),
    
t7 AS (SELECT courier_id,
              order_id,
              courier_birth_date,
              user_id,
              user_birth_date,
              last_time
        FROM   t5
-- находим дату последнего заказа, относительноо которой будем рассчитывать возраст курьеров и пользователей
        LEFT JOIN (SELECT order_id,
                          max(time)::date AS last_time
                   FROM   user_actions
                   GROUP BY order_id) t8 USING(order_id))
-- отбираем необходимые по условию колонки и подсчитываем возраст пользователей и курьеров
SELECT order_id,
       user_id,
       (DATE_PART('year', AGE(last_time, user_birth_date)))::integer AS user_age,
       courier_id,
       (DATE_PART('year', AGE(last_time, courier_birth_date)))::integer AS courier_age
FROM   t7
ORDER BY order_id
```

**Задание №21**

Выясните, какие пары товаров покупают вместе чаще всего.

Пары товаров сформируйте на основе таблицы с заказами. Отменённые заказы не учитывайте. В качестве результата выведите две колонки — колонку с парами наименований товаров и колонку со значениями, показывающими, сколько раз конкретная пара встретилась в заказах пользователей. Колонки назовите соответственно **pair** и **count_pair**.

Пары товаров должны быть представлены в виде списков из двух наименований. Пары товаров внутри списков должны быть отсортированы в порядке возрастания наименования. Результат отсортируйте сначала по убыванию частоты встречаемости пары товаров в заказах, затем по колонке **pair** — по возрастанию.

Поля в результирующей таблице: **pair**, **count_pair**

```sql
WITH
t1 AS (SELECT order_id,
              UNNEST(product_ids) AS product_id
       FROM   orders
       WHERE  order_id NOT IN(SELECT order_id
                              FROM   user_actions
                              WHERE  action = 'cancel_order')), 
t2 AS (SELECT *
       FROM   t1 JOIN products USING(product_id))
SELECT pair,
       COUNT(pair) as count_pair
FROM   (SELECT DISTINCT a.order_id,
                        ARRAY_SORT(array[a.name, b.name]) AS pair
        FROM   t2 AS a JOIN t2 AS b
                ON a.order_id = b.order_id AND a.product_id < b.product_id) AS der
GROUP BY pair
ORDER BY count_pair DESC, pair
```
</details>
</details>

<details>
  
<summary>Решение заданий из тренажера <a href="https://sql-academy.org/ru/trainer">SQL Academy</a>  </summary>

  
# Задание №1

**Задача:** Вывести имена всех людей, которые есть в базе данных авиакомпаний.

**Поля в результирующей таблице:**
- `name`

```sql
SELECT name
FROM Passenger
```

---

# Задание №2

**Задача:** Вывести названия всех авиакомпаний.

**Поля в результирующей таблице:**
- `name`

```sql
SELECT name
FROM Company
```

---

# Задание №3

**Задача:** Вывести все рейсы, совершенные из Москвы.

**Поля в результирующей таблице:**
- `*`

```sql
SELECT *
FROM Trip
WHERE town_from = 'Moscow'
```

---

# Задание №4

**Задача:** Вывести имена людей, которые заканчиваются на "man".

**Поля в результирующей таблице:**
- `name`

```sql
SELECT name
FROM Passenger
WHERE name LIKE '%man'
```

---

# Задание №5

**Задача:** Вывести количество рейсов, совершенных на TU-134.

**Поля в результирующей таблице:**
- `count`

```sql
SELECT COUNT(plane) AS count
FROM Trip
WHERE plane = 'TU-134'
```

---

# Задание №6

**Задача:** Какие компании совершали перелеты на Boeing.

**Поля в результирующей таблице:**
- `name`

```sql
SELECT DISTINCT name
FROM Trip
JOIN Company ON Trip.company = Company.id
WHERE plane = 'Boeing'
```

---

# Задание №7

**Задача:** Вывести все названия самолётов, на которых можно улететь в Москву (Moscow).

**Поля в результирующей таблице:**
- `plane`

```sql
SELECT DISTINCT plane
FROM Trip
WHERE town_to = 'Moscow'
```

---

# Задание №8

**Задача:** Вывести рейсы из Парижа (Paris) и сколько времени это займёт.

**Поля в результирующей таблице:**
- `town_to`
- `flight_time`

```sql
SELECT town_to,
       TIMEDIFF(time_in, time_out) AS flight_time
FROM Trip
WHERE town_from = 'Paris'
```

---

# Задание №9

**Задача:** Какие компании организуют перелеты из Владивостока (Vladivostok)?

**Поля в результирующей таблице:**
- `name`

```sql
SELECT name
FROM Trip
LEFT JOIN Company ON Trip.company = Company.id
WHERE town_from = 'Vladivostok'
```

---

# Задание №10

**Задача:** Вывести вылеты, совершенные с 10 ч. по 14 ч. 1 января 1900 г.

**Поля в результирующей таблице:**
- `*`

```sql
SELECT *
FROM Trip
WHERE time_out BETWEEN '1900-01-01T10:00:00.000Z' AND '1900-01-01T14:00:00.000Z'
```

---

# Задание №11

**Задача:** Вывести пассажиров с самым длинным ФИО. Пробелы, дефисы и точки считаются частью имени.

**Поля в результирующей таблице:**
- `name`

```sql
SELECT name
FROM Passenger
WHERE LENGTH(name) = (SELECT MAX(LENGTH(name)) FROM Passenger)
```

---

# Задание №12

**Задача:** Вывести идентификаторы всех рейсов и количество пассажиров на них. Если пассажиров нет, вывести 0.

**Поля в результирующей таблице:**
- `id`
- `count`

```sql
SELECT Trip.id,
       COUNT(passenger) AS count
FROM Trip
LEFT JOIN Pass_in_trip ON Trip.id = Pass_in_trip.trip
GROUP BY Trip.id
```

---

# Задание №13

**Задача:** Вывести имена людей, у которых есть полный тёзка среди пассажиров.

**Поля в результирующей таблице:**
- `name`

```sql
SELECT name
FROM Passenger
GROUP BY name
HAVING COUNT(*) > 1
```

---

# Задание №14

**Задача:** В какие города летал Bruce Willis.

**Поля в результирующей таблице:**
- `town_to`

```sql
SELECT town_to
FROM Trip
INNER JOIN Pass_in_trip ON Trip.id = Pass_in_trip.trip
INNER JOIN Passenger ON Pass_in_trip.passenger = Passenger.id
WHERE name = 'Bruce Willis'
```

---

# Задание №15

**Задача:** Вывести идентификатор пассажира Стив Мартин (Steve Martin) и дату и время его прилёта в Лондон (London).

**Поля в результирующей таблице:**
- `id`
- `time_in`

```sql
SELECT Passenger.id,
       time_in
FROM Trip
INNER JOIN Pass_in_trip ON Trip.id = Pass_in_trip.trip
INNER JOIN Passenger ON Pass_in_trip.passenger = Passenger.id
WHERE town_to = 'London'
  AND name = 'Steve Martin'
```

---

# Задание №16

**Задача:** Вывести отсортированный по количеству перелетов (по убыванию) и имени (по возрастанию) список пассажиров, совершивших хотя бы 1 полет.

**Поля в результирующей таблице:**
- `name`
- `count`

```sql
SELECT name,
       COUNT(trip) AS count
FROM Pass_in_trip
INNER JOIN Passenger ON Pass_in_trip.passenger = Passenger.id
GROUP BY name
ORDER BY count DESC, name
```

---

# Задание №17

**Задача:** Определить, сколько потратил в 2005 году каждый из членов семьи. Не выводить тех, кто ничего не потратил.

**Поля в результирующей таблице:**
- `member_name`
- `status`
- `costs`

```sql
SELECT member_name,
       status,
       SUM(unit_price * amount) AS costs
FROM FamilyMembers
LEFT JOIN Payments ON FamilyMembers.member_id = Payments.family_member
WHERE YEAR(date) = 2005
GROUP BY member_name, status
```

---

# Задание №18

**Задача:** Вывести имя самого старшего человека. Если таких несколько, вывести их всех.

```sql
SELECT member_name
FROM FamilyMembers
WHERE birthday = (SELECT MIN(birthday) FROM FamilyMembers)
```
# Задание №19

**Задача:** Определить, кто из членов семьи покупал картошку (potato).

**Поля в результирующей таблице:**
- `status`

```sql
SELECT DISTINCT status
FROM FamilyMembers
	LEFT JOIN Payments ON FamilyMembers.member_id = Payments.family_member
	JOIN Goods ON Payments.good = Goods.good_id
WHERE good_name = 'potato'
```
---

# Задание №20

**Задача:** Сколько и кто из семьи потратил на развлечения (entertainment). Вывести статус в семье, имя, сумму

**Поля в результирующей таблице:**
- `status`
- `member_name`
- `costs`

```sql
SELECT status,
	member_name,
	SUM(unit_price * amount) AS costs
FROM FamilyMembers
	LEFT JOIN Payments ON FamilyMembers.member_id = Payments.family_member
	JOIN Goods ON Payments.good = Goods.good_id
	JOIN GoodTypes ON Goods.type = GoodTypes.good_type_id
WHERE good_type_name = 'entertainment'
GROUP BY member_name,
	status
```
---
# Задание №21

**Задача:** Определить товары, которые покупали более 1 раза

**Поля в результирующей таблице:**
- `good_name`

```sql
SELECT good_name
FROM Goods
	LEFT JOIN Payments ON Goods.good_id = Payments.good
GROUP BY good_name
HAVING COUNT(good_name) > 1
```
---
# Задание №22

**Задача:** Найти имена всех матерей (mother)

**Поля в результирующей таблице:**
- `member_name`

```sql
SELECT member_name
FROM FamilyMembers
WHERE status = 'mother'
GROUP BY member_name
```
---

# Задание №23

**Задача:** Найдите самый дорогой деликатес (delicacies) и выведите его цену

**Поля в результирующей таблице:**
- `good_name`
- `unit_price`

```sql
SELECT good_name,
	unit_price
FROM Goods
	INNER JOIN Payments ON Goods.good_id = Payments.good
	INNER JOIN GoodTypes ON Goods.type = GoodTypes.good_type_id
WHERE good_type_name = 'delicacies'
ORDER BY unit_price DESC
LIMIT 1
```
Альтернативное решение

```sql
WITH
t1 AS (SELECT good_name, unit_price
       FROM Goods
       INNER JOIN Payments
       ON Goods.good_id=Payments.good
       INNER JOIN GoodTypes
       ON Goods.type = GoodTypes.good_type_id
       WHERE good_type_name = 'delicacies')

SELECT good_name, unit_price
FROM t1
WHERE unit_price IN (SELECT MAX(unit_price) FROM t1)
```
---

# Задание №24

**Задача:** Определить кто и сколько потратил в июне 2005

**Поля в результирующей таблице:**
- `member_name`
- `costs`

```sql
SELECT member_name,
	   SUM(amount * unit_price) AS costs
FROM FamilyMembers
	INNER JOIN Payments ON FamilyMembers.member_id = Payments.family_member
WHERE date > '2005-05-31' and date < '2005-07-01'
GROUP BY member_name
```
# Задание №25

**Задача:** Определить, какие товары не покупались в 2005 году

**Поля в результирующей таблице:**
- `good_name`

```sql
WITH t1 AS (SELECT good_name
            FROM Goods
            JOIN Payments ON Goods.good_id = Payments.good
            WHERE YEAR(date) = 2005)
    
SELECT good_name
FROM Goods
WHERE good_name NOT IN(SELECT good_name
        		       FROM t1)
```

# Задание №26

**Задача:** Определить группы товаров, которые не приобретались в 2005 году

**Поля в результирующей таблице:**
- `good_type_name`

```sql
WITH t1 AS (SELECT good_type_name
            FROM GoodTypes
            JOIN Goods ON GoodTypes.good_type_id = Goods.type
            JOIN Payments ON Goods.good_id = Payments.good
            WHERE YEAR(date) = 2005)
    
SELECT good_type_name
FROM GoodTypes
WHERE good_type_name NOT IN(SELECT good_type_name
                		    FROM t1)
```

# Задание №27

**Задача:** Узнайте, сколько было потрачено на каждую из групп товаров в 2005 году. Выведите название группы и потраченную на неё сумму. Если потраченная сумма равна нулю, т.е. товары из этой группы не покупались в 2005 году, то не выводите её.

**Поля в результирующей таблице:**
- `good_type_name`, `costs`

```sql
SELECT good_type_name,
	SUM(unit_price * amount) AS costs
FROM Payments
	JOIN Goods ON Payments.good = Goods.good_id
	JOIN GoodTypes ON Goods.type = GoodTypes.good_type_id
WHERE YEAR(date) = 2005
GROUP BY good_type_name
```

# Задание №28

**Задача:** Сколько рейсов совершили авиакомпании из Ростова (Rostov) в Москву (Moscow) ?

**Поля в результирующей таблице:**
- `count`

```sql
SELECT count(*) as count
FROM Trip
WHERE town_from = 'Rostov'
	AND town_to = 'Moscow'
```

# Задание №29

**Задача:** Выведите имена пассажиров улетевших в Москву (Moscow) на самолете TU-134. В ответе не должно быть дубликатов.

**Поля в результирующей таблице:**
- `name`

```sql
SELECT DISTINCT name
FROM Trip
	JOIN Pass_in_trip ON Trip.id = Pass_in_trip.trip
	JOIN Passenger ON Pass_in_trip.passenger = Passenger.id
WHERE town_to = 'Moscow'
	AND plane = 'TU-134'
```

# Задание №30

**Задача:** Выведите нагруженность (число пассажиров) каждого рейса (trip). Результат вывести в отсортированном виде по убыванию нагруженности.

**Поля в результирующей таблице:**
- `trip`, `count`

```sql
SELECT trip,
	COUNT(passenger) as count
FROM Pass_in_trip
GROUP BY trip
ORDER BY count DESC
```

# Задание №31

**Задача:** Вывести всех членов семьи с фамилией Quincey.

**Поля в результирующей таблице:**
- `*`

```sql
SELECT *
FROM FamilyMembers
WHERE member_name LIKE '%Quincey'
```

# Задание №32

**Задача:** Вывести средний возраст людей (в годах), хранящихся в базе данных. Результат округлите до целого в меньшую сторону.

**Поля в результирующей таблице:**
- `age`

```sql
SELECT FLOOR(
		AVG(TIMESTAMPDIFF(YEAR, birthday, CURRENT_TIMESTAMP))
	) AS age
FROM FamilyMembers;
```

# Задание №33

**Задача:** Найдите среднюю цену икры на основе данных, хранящихся в таблице Payments. В базе данных хранятся данные о покупках красной (red caviar) и черной икры (black caviar). В ответе должна быть одна строка со средней ценой всей купленной когда-либо икры.

**Поля в результирующей таблице:**
- `cost`

```sql
SELECT AVG(unit_price) as cost
FROM Payments
	JOIN Goods ON Payments.good = Goods.good_id
WHERE good_name = 'black caviar'
	OR good_name = 'red caviar'
```

# Задание №34

**Задача:** Сколько всего 10-ых классов

**Поля в результирующей таблице:**
- `count`

```sql
SELECT COUNT(name) as count
FROM class
WHERE name like '10%'
```

# Задание №35

**Задача:** Сколько различных кабинетов школы использовались 2 сентября 2019 года для проведения занятий?

**Поля в результирующей таблице:**
- `count`

```sql
SELECT COUNT(DISTINCT classroom) as count
FROM Schedule
WHERE DATE(date) = '2019-09-02'
```





</details>





